                }

                // Ensure bot is stopped before casting
                if (bot->isMoving())
                {
                    bot->StopMoving();
                    // Wait for next update cycle to ensure movement stops
                    botAI->SetNextCheckDelay(200);
                    return true;
                }

                // =========================================
                // ANTI-OSCILLATION: Final Area Clearance Check
                // =========================================
                // Before starting the capture cast, do a final enemy scan
                // This catches enemies who approached during dismount/movement
                TeamId enemyTeam = bot->GetTeamId() == TEAM_ALLIANCE ? TEAM_HORDE : TEAM_ALLIANCE;
                uint32 finalEnemyCount = getPlayersInArea(enemyTeam, go->GetPosition(), 30.0f, true);
                
                if (finalEnemyCount > 0)
                {
                    LOG_DEBUG("playerbots", "BGTactics: {} aborting capture - {} enemies detected during final check",
                              bot->GetName(), finalEnemyCount);

                    // Enemy approached while we were preparing to capture
                    // Set cooldown and enter combat mode
                    SetCaptureCooldown(5000);  // 5 second cooldown

                    // Clear preparing capture flag - we're entering combat mode
                    if (context)
                    {
                        auto* prepCapture = context->GetValue<bool>("preparing capture");
                        if (prepCapture)
                            prepCapture->Set(false);
                    }

                    // Find and engage the enemy
                    Unit* enemyPlayer = AI_VALUE(Unit*, "enemy player target");
                    if (enemyPlayer)
                    {
                        auto* currentTarget = context->GetValue<Unit*>("current target");
                        if (currentTarget)
                            currentTarget->Set(enemyPlayer);
                    }

                    return false;  // Return to combat mode
                }

                // Clear preparing capture flag before casting
                if (context)
                {
                    auto* prepCapture = context->GetValue<bool>("preparing capture");
                    if (prepCapture)
                        prepCapture->Set(false);
                }

                // Cast the capture spell
                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(SPELL_CAPTURE_BANNER);
                if (!spellInfo)
                    return false;

                Spell* spell = new Spell(bot, spellInfo, TRIGGERED_NONE);
                spell->m_targets.SetGOTarget(go);
                spell->prepare(&spell->m_targets);

                botAI->WaitForSpellCast(spell);

                resetObjective();
                return true;
            }
            case BATTLEGROUND_WS:
            {
                if (dist < INTERACTION_DISTANCE)
                {
                    // Handle flag capture at base
                    if (isWsBaseFlag)
                    {
                        if (bot->GetTeamId() == TEAM_HORDE)
                        {
                            WorldPacket data(CMSG_AREATRIGGER);
                            data << uint32(BG_WS_TRIGGER_HORDE_FLAG_SPAWN);
                            bot->GetSession()->HandleAreaTriggerOpcode(data);
                        }
                        else
                        {
                            WorldPacket data(CMSG_AREATRIGGER);
                            data << uint32(BG_WS_TRIGGER_ALLIANCE_FLAG_SPAWN);
                            bot->GetSession()->HandleAreaTriggerOpcode(data);
                        }
                        return true;
                    }

                    // Dismount before picking up flag
                    if (bot->IsMounted())
                    {
                        bot->RemoveAurasByType(SPELL_AURA_MOUNTED);
                        // Set preparing capture flag to prevent mount/dismount loops
                        if (context)
                        {
                            auto* prepCapture = context->GetValue<bool>("preparing capture");
                            if (prepCapture)
                                prepCapture->Set(true);
                        }
                        // Wait for next update cycle to ensure dismount completes
                        botAI->SetNextCheckDelay(500);
                        return true;
                    }

                    if (bot->IsInDisallowedMountForm())
                    {
                        bot->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
                        // Wait for next update cycle to ensure form change completes
                        botAI->SetNextCheckDelay(500);
                        return true;
                    }

                    // Pick up the flag
                    WorldPacket data(CMSG_GAMEOBJ_USE);
                    data << go->GetGUID();
                    // Clear preparing capture flag before interacting
                    if (context)
                    {
                        auto* prepCapture = context->GetValue<bool>("preparing capture");
                        if (prepCapture)
                            prepCapture->Set(false);
                    }
                    bot->GetSession()->HandleGameObjectUseOpcode(data);

                    resetObjective();
                    return true;
                }
                else
                {
                    // Move to flag if not in range
                    return MoveTo(bot->GetMapId(), go->GetPositionX(), go->GetPositionY(), go->GetPositionZ());
                }
            }
            case BATTLEGROUND_EY:
            {  // Handle Netherstorm flag capture requiring a channel
                if (dist < INTERACTION_DISTANCE)
                {
                    // Dismount before interacting
                    if (bot->IsMounted())
                    {
                        bot->RemoveAurasByType(SPELL_AURA_MOUNTED);
                        // Set preparing capture flag to prevent mount/dismount loops
                        if (context)
                        {
                            auto* prepCapture = context->GetValue<bool>("preparing capture");
                            if (prepCapture)
                                prepCapture->Set(true);
                        }
                        // Wait for next update cycle to ensure dismount completes
                        botAI->SetNextCheckDelay(500);
                        return true;
                    }

                    if (bot->IsInDisallowedMountForm())
                    {
                        bot->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT);
                        botAI->SetNextCheckDelay(500);
                        return true;
                    }

                    // Handle center flag differently (requires spell cast)
                    if (isEyCenterFlag)
                    {
                        for (uint8 type = CURRENT_MELEE_SPELL; type <= CURRENT_CHANNELED_SPELL; ++type)
                        {
                            if (Spell* currentSpell = bot->GetCurrentSpell(static_cast<CurrentSpellTypes>(type)))
                            {
                                // m_spellInfo may be null in some states: protect access
                                if (currentSpell->m_spellInfo && currentSpell->m_spellInfo->Id == SPELL_CAPTURE_BANNER)
                                {
                                    bot->StopMoving();
                                    botAI->SetNextCheckDelay(500);
                                    return true;
                                }
                            }
                        }

                        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(SPELL_CAPTURE_BANNER);
                        if (!spellInfo)
                            return false;

                        Spell* spell = new Spell(bot, spellInfo, TRIGGERED_NONE);
                        spell->m_targets.SetGOTarget(go);

                        bot->StopMoving();
                        // Clear preparing capture flag before casting
                        if (context)
                        {
                            auto* prepCapture = context->GetValue<bool>("preparing capture");
                            if (prepCapture)
                                prepCapture->Set(false);
                        }
                        spell->prepare(&spell->m_targets);

                        botAI->WaitForSpellCast(spell);
                        resetObjective();
                        return true;
                    }

                    // Pick up dropped flag
                    WorldPacket data(CMSG_GAMEOBJ_USE);
                    data << go->GetGUID();
                    // Clear preparing capture flag before interacting
                    if (context)
                    {
                        auto* prepCapture = context->GetValue<bool>("preparing capture");
                        if (prepCapture)
                            prepCapture->Set(false);
                    }
                    bot->GetSession()->HandleGameObjectUseOpcode(data);

                    resetObjective();
                    return true;
                }
                else
                {
                    // Move to flag if not in range
                    return MoveTo(bot->GetMapId(), go->GetPositionX(), go->GetPositionY(), go->GetPositionZ());
                }
            }
            default:
                break;
        }
    }

    return false;
}

bool BGTactics::flagTaken()
{
    BattlegroundWS* bg = (BattlegroundWS*)bot->GetBattleground();
    if (!bg)
        return false;

    return !bg->GetFlagPickerGUID(bg->GetOtherTeamId(bot->GetTeamId())).IsEmpty();
}

bool BGTactics::teamFlagTaken()
{
    BattlegroundWS* bg = (BattlegroundWS*)bot->GetBattleground();
    if (!bg)
        return false;

    return !bg->GetFlagPickerGUID(bot->GetTeamId()).IsEmpty();
}

bool BGTactics::protectFC()
{
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return false;

    Unit* teamFC = AI_VALUE(Unit*, "team flag carrier");

    if (!teamFC || teamFC == bot)
    {
        return false;
    }

    if (!bot->IsInCombat() && !bot->IsWithinDistInMap(teamFC, 20.0f))
    {
        // Get the flag carrier's position
        float fcX = teamFC->GetPositionX();
        float fcY = teamFC->GetPositionY();
        float fcZ = teamFC->GetPositionZ();
        uint32 mapId = bot->GetMapId();

        return MoveNear(mapId, fcX, fcY, fcZ, 5.0f, MovementPriority::MOVEMENT_NORMAL);
    }

    return false;
}

bool BGTactics::useBuff()
{
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return false;

    BattlegroundTypeId bgType = bg->GetBgTypeID();
    if (bgType == BATTLEGROUND_RB)
        bgType = bg->GetBgTypeID(true);

    GuidVector closeObjects = AI_VALUE(GuidVector, "nearest game objects no los");
    if (closeObjects.empty())
        return false;

    bool needRegen = bot->GetHealthPct() < sPlayerbotAIConfig->mediumHealth ||
                     (AI_VALUE2(bool, "has mana", "self target") &&
                      AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig->mediumMana);
    bool needSpeed = (bgType != BATTLEGROUND_WS || bot->HasAura(BG_WS_SPELL_WARSONG_FLAG) ||
                      bot->HasAura(BG_WS_SPELL_SILVERWING_FLAG) || bot->HasAura(BG_EY_NETHERSTORM_FLAG_SPELL)) ||
                     !(teamFlagTaken() || flagTaken());
    bool foundBuff = false;

    for (ObjectGuid const guid : closeObjects)
    {
        GameObject* go = botAI->GetGameObject(guid);
        if (!go)
            continue;

        if (!go->isSpawned())
            continue;

        // use speed buff only if close
        if (sServerFacade->IsDistanceGreaterThan(sServerFacade->GetDistance2d(bot, go),
                                                 go->GetEntry() == Buff_Entries[0] ? 20.0f : 50.0f))
            continue;

        if (needSpeed && go->GetEntry() == Buff_Entries[0])
            foundBuff = true;

        if (needRegen && go->GetEntry() == Buff_Entries[1])
            foundBuff = true;

        // do not move to Berserk buff if bot is healer or has flag
        if (!(bot->HasAura(BG_WS_SPELL_WARSONG_FLAG) || bot->HasAura(BG_WS_SPELL_SILVERWING_FLAG) ||
              bot->HasAura(BG_EY_NETHERSTORM_FLAG_SPELL)) &&
            !botAI->IsHeal(bot) && go->GetEntry() == Buff_Entries[2])
            foundBuff = true;

        if (foundBuff)
        {
            // std::ostringstream out;
            // out << "Moving to buff...";
            // bot->Say(out.str(), LANG_UNIVERSAL);
            return MoveTo(go->GetMapId(), go->GetPositionX(), go->GetPositionY(), go->GetPositionZ());
        }
    }

    return false;
}

uint32 BGTactics::getPlayersInArea(TeamId teamId, Position point, float range, bool combat)
{
    uint32 defCount = 0;

    if (!bot->InBattleground())
        return false;

    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return 0;

    for (auto& guid : bg->GetBgMap()->GetPlayers())
    {
        Player* player = guid.GetSource();
        if (!player)
            continue;

        if (player->IsAlive() && (teamId == TEAM_NEUTRAL || teamId == player->GetTeamId()))
        {
            if (!combat && player->IsInCombat())
                continue;

            if (sServerFacade->GetDistance2d(player, point.GetPositionX(), point.GetPositionY()) < range)
                ++defCount;
        }
    }

    return defCount;
}

// check Isle of Conquest Keep position
bool BGTactics::IsLockedInsideKeep()
{
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return false;

    BattlegroundTypeId bgType = bg->GetBgTypeID();
    if (bgType == BATTLEGROUND_RB)
        bgType = bg->GetBgTypeID(true);

    if (bgType != BATTLEGROUND_IC)
        return false;

    bool isInside = false;
    if (bot->GetTeamId() == TEAM_ALLIANCE && bot->GetPositionX() < 410.0f && bot->GetPositionY() > -900.0f &&
        bot->GetPositionY() < -765.0f)
        isInside = true;
    if (bot->GetTeamId() == TEAM_HORDE && bot->GetPositionX() > 1153.0f && bot->GetPositionY() > -849.0f &&
        bot->GetPositionY() < -679.0f)
        isInside = true;

    if (!isInside)
        return false;

    GuidVector closeObjects;
    closeObjects = *context->GetValue<GuidVector>("nearest game objects no los");
    if (closeObjects.empty())
        return moveToStart(true);

    GameObject* closestPortal = nullptr;
    float closestDistance = 100.0f;
    bool gateLock = false;

    // check inner gates status
    // ALLIANCE
    if (bot->GetTeamId() == TEAM_ALLIANCE)
    {
        if (GameObject* go = bg->GetBGObject(BG_IC_GO_DOODAD_PORTCULLISACTIVE02))
        {
            if (go->isSpawned())
            {
                gateLock = go->getLootState() != GO_ACTIVATED;
            }
            else
            {
                gateLock = false;
            }
        }
    }
    // HORDE
    if (bot->GetTeamId() == TEAM_HORDE)
    {
        if (GameObject* go = bg->GetBGObject(BG_IC_GO_HORDE_KEEP_PORTCULLIS))
        {
            if (go->isSpawned())
            {
                gateLock = go->getLootState() != GO_ACTIVATED;
            }
            else
            {
                gateLock = false;
            }
        }
    }

    for (ObjectGuid const& guid : closeObjects)
    {
        GameObject* go = botAI->GetGameObject(guid);
        if (!go)
            continue;

        // ALLIANCE
        // get closest portal
        if (bot->GetTeamId() == TEAM_ALLIANCE && go->GetEntry() == GO_TELEPORTER_4)
        {
            float tempDist = sServerFacade->GetDistance2d(bot, go->GetPositionX(), go->GetPositionY());

            if (sServerFacade->IsDistanceLessThan(tempDist, closestDistance))
            {
                closestDistance = tempDist;
                closestPortal = go;
            }
        }

        // HORDE
        // get closest portal
        if (bot->GetTeamId() == TEAM_HORDE && go->GetEntry() == GO_TELEPORTER_2)
        {
            float tempDist = sServerFacade->GetDistance2d(bot, go->GetPositionX(), go->GetPositionY());

            if (sServerFacade->IsDistanceLessThan(tempDist, closestDistance))
            {
                closestDistance = tempDist;
                closestPortal = go;
            }
        }
    }

    // portal not found, move closer
    if (gateLock && !closestPortal)
        return moveToStart(true);

    // portal not found, move closer
    if (!gateLock && !closestPortal)
        return moveToStart(true);

    // nothing found, allow move through
    if (!gateLock || !closestPortal)
        return false;

    // portal found
    if (closestPortal)
    {
        // Check if bot recently used teleporter (prevents infinite loop)
        time_t now = time(nullptr);
        auto it = botTeleporterCooldowns.find(bot->GetGUID());
        
        if (it != botTeleporterCooldowns.end())
        {
            time_t timeSinceUse = now - it->second;
            if (timeSinceUse < 30) // 30 second cooldown - enough time to fully exit keep area
            {
                // SAFETY FIX: If bot is stuck near the teleporter destination, force move them away
                if (IsStuck() && bot->IsWithinDistInMap(closestPortal, 15.0f))
                {
                    LOG_INFO("playerbots", "BGTactics: {} stuck near IoC teleporter after use, forcing robust move away", bot->GetName());
                    
                    // Move to a safe point away from the teleporter/railing
                    // Alliance keep exit area (East of gate)
                    // Horde keep exit area (West of gate)
                    float targetX = (bot->GetTeamId() == TEAM_ALLIANCE) ? bot->GetPositionX() + 20.0f : bot->GetPositionX() - 20.0f;
                    float targetY = bot->GetPositionY() + (frand(-10.0f, 10.0f)); // Add some randomness to Y to avoid clustering
                    
                    MoveTo(bot->GetMapId(), targetX, targetY, bot->GetPositionZ());
                }

                // Recently used teleporter - DON'T check if inside keep anymore
                // Just return false to allow normal movement
                LOG_DEBUG("playerbots", "BGTactics: {} recently used IoC teleporter ({} sec ago) - ignoring keep check",
                          bot->GetName().c_str(), timeSinceUse);
                return false; // Don't block movement
            }
            else
            {
                // Cooldown expired - clear it
                botTeleporterCooldowns.erase(it);
            }
        }
        
        // if close to portal
        if (bot->IsWithinDistInMap(closestPortal, INTERACTION_DISTANCE))
        {
            WorldPacket data(CMSG_GAMEOBJ_USE);
            data << closestPortal->GetGUID();
            bot->GetSession()->HandleGameObjectUseOpcode(data);
            
            // Record teleporter use time
            botTeleporterCooldowns[bot->GetGUID()] = now;
            
            LOG_DEBUG("playerbots", "BGTactics: {} using IoC teleporter - 30sec cooldown set",
                      bot->GetName().c_str());
            
            return true;
        }
        else
        {
            // Move toward portal
            return MoveTo(bot->GetMapId(), closestPortal->GetPositionX(), closestPortal->GetPositionY(),
                          closestPortal->GetPositionZ());
        }
    }

    return moveToStart(true);
}

// Game State Awareness Implementation
bool BGTactics::IsLosingBadly(Battleground* bg)
{
    if (!bg)
        return false;
    
    BattlegroundTypeId bgType = bg->GetBgTypeID();
    if (bgType == BATTLEGROUND_RB)
        bgType = bg->GetBgTypeID(true);
    
    TeamId myTeam = bot->GetTeamId();
    
    switch (bgType)
    {
        case BATTLEGROUND_AB:
        case BATTLEGROUND_EY:
        {
            // Check score differential
            uint32 myScore = bg->GetTeamScore(myTeam);
            uint32 enemyScore = bg->GetTeamScore(bg->GetOtherTeamId(myTeam));
            
            // Losing badly if behind by 500+ points
            if (enemyScore > myScore + 500)
                return true;
            
            // Or if enemy has significantly more bases
            uint32 myBases = GetTeamBasesControlled(bg, myTeam);
            uint32 enemyBases = GetTeamBasesControlled(bg, bg->GetOtherTeamId(myTeam));
            if (enemyBases >= 4 && myBases <= 1)
                return true;
            
            break;
        }
        case BATTLEGROUND_WS:
        {
            // Check flag captures
            uint32 myScore = bg->GetTeamScore(myTeam);
            uint32 enemyScore = bg->GetTeamScore(bg->GetOtherTeamId(myTeam));
            
            // Losing badly if behind by 2 captures
            if (enemyScore >= myScore + 2)
                return true;
            
            break;
        }
        case BATTLEGROUND_AV:
        {
            // Check reinforcements
            uint32 myReinforcements = bg->GetTeamScore(myTeam);
            uint32 enemyReinforcements = bg->GetTeamScore(bg->GetOtherTeamId(myTeam));
            
            // Losing badly if down by 200+ reinforcements
            if (myReinforcements + 200 < enemyReinforcements)
                return true;
            
            break;
        }
        default:
            break;
    }
    
    return false;
}

bool BGTactics::IsWinning(Battleground* bg)
{
    if (!bg)
        return false;
    
    BattlegroundTypeId bgType = bg->GetBgTypeID();
    if (bgType == BATTLEGROUND_RB)
        bgType = bg->GetBgTypeID(true);
    
    TeamId myTeam = bot->GetTeamId();
    
    switch (bgType)
    {
        case BATTLEGROUND_AB:
        case BATTLEGROUND_EY:
        {
            uint32 myScore = bg->GetTeamScore(myTeam);
            uint32 enemyScore = bg->GetTeamScore(bg->GetOtherTeamId(myTeam));
            
            // Winning if ahead by 300+ points
            if (myScore > enemyScore + 300)
                return true;
            
            // Or controlling majority of bases
            uint32 myBases = GetTeamBasesControlled(bg, myTeam);
            if (myBases >= 4)
                return true;
            
            break;
        }
        case BATTLEGROUND_WS:
        {
            uint32 myScore = bg->GetTeamScore(myTeam);
            uint32 enemyScore = bg->GetTeamScore(bg->GetOtherTeamId(myTeam));
            
            // Winning if ahead in captures
            if (myScore >= enemyScore + 2)
                return true;
            
            break;
        }
        case BATTLEGROUND_AV:
        {
            uint32 myReinforcements = bg->GetTeamScore(myTeam);
            uint32 enemyReinforcements = bg->GetTeamScore(bg->GetOtherTeamId(myTeam));
            
            // Winning if up by 150+ reinforcements
            if (myReinforcements > enemyReinforcements + 150)
                return true;
            
            break;
        }
        default:
            break;
    }
    
    return false;
}

bool BGTactics::ShouldPlayAggressive(Battleground* bg)
{
    if (!bg)
        return false;
    
    // Play aggressive if losing badly (need to make comeback)
    if (IsLosingBadly(bg))
        return true;
    
    // Play aggressive early game (first 3 minutes)
    uint32 elapsed = GameTime::GetGameTime().count() - bg->GetStartTime();
    if (elapsed < 180) // First 3 minutes
        return true;
    
    // Don't play aggressive if winning significantly
    if (IsWinning(bg))
        return false;
    
    // Default: balanced approach
    return false;
}

bool BGTactics::ShouldPlayDefensive(Battleground* bg)
{
    if (!bg)
        return false;
    
    // Play defensive if winning
    if (IsWinning(bg))
        return true;
    
    // Play defensive late game with lead
    BattlegroundTypeId bgType = bg->GetBgTypeID();
    if (bgType == BATTLEGROUND_RB)
        bgType = bg->GetBgTypeID(true);
    
    TeamId myTeam = bot->GetTeamId();
    uint32 myScore = bg->GetTeamScore(myTeam);
    uint32 enemyScore =bg->GetTeamScore(bg->GetOtherTeamId(myTeam));
    
    uint32 elapsed = GameTime::GetGameTime().count() - bg->GetStartTime();
    if (elapsed > 600 && myScore > enemyScore) // Last 10+ min with lead
        return true;
    
    return false;
}

uint32 BGTactics::GetTeamBasesControlled(Battleground* bg, TeamId teamId)
{
    if (!bg)
        return 0;
    
    BattlegroundTypeId bgType = bg->GetBgTypeID();
    if (bgType == BATTLEGROUND_RB)
        bgType = bg->GetBgTypeID(true);
    
    uint32 basesControlled = 0;
    
    // Currently only implemented for Arathi Basin and EotS
    if (bgType == BATTLEGROUND_AB)
    {
        for (uint8 node = 0; node < 5; ++node)
        {
            GameObject* banner = bg->GetBGObject(node * 8 + (teamId == TEAM_ALLIANCE ? 0 : 1));
            if (banner && banner->isSpawned())
                basesControlled++;
        }
    }
    else if (bgType == BATTLEGROUND_EY)
    {
        BattlegroundEY* bgEY = bg->ToBattlegroundEY();
        for (uint32 i = 0; i < 4; ++i)
        {
            if (bgEY->GetCapturePointInfo(i)._ownerTeamId == teamId)
                basesControlled++;
        }
    }
    
    return basesControlled;
}

// Opening Strategy Implementation
bool BGTactics::IsGameOpening(Battleground* bg)
{
    if (!bg)
        return false;
    
    // Check if BG is started
    if (bg->GetStatus() != STATUS_IN_PROGRESS)
        return false;

    // Use sWorld->GetGameTime() if GameTime::GetGameTime() is problematic, 
    // but existing code used GameTime::GetGameTime().count().
    // We stick to the existing method that compiled before, but change threshold.
    uint32 elapsed = GameTime::GetGameTime().count() - bg->GetStartTime();
    return elapsed < 45; // Reduced from 120s to 45s for tighter opening rush
}

uint32 BGTactics::GetAssignedOpeningNode(Battleground* bg)
{
    // Distribution:
    // 10% - Home Base (Stables/Farm) - ~1-2 bots
    // 45% - Blacksmith (Mid) - ~6-7 bots (Main force)
    // 20% - Lumber Mill - ~3 bots
    // 25% - Gold Mine - ~3 bots
    
    uint32 roll = urand(0, 100);
    TeamId team = bot->GetTeamId();
    
    if (team == TEAM_ALLIANCE)
    {
        if (roll < 10) return AB_NODE_STABLES;      // 10%
        if (roll < 55) return AB_NODE_BLACKSMITH;   // 45%
        if (roll < 75) return AB_NODE_LUMBER_MILL;  // 20%
        return AB_NODE_GOLD_MINE;                   // 25%
    }
    else // HORDE
    {
        if (roll < 10) return AB_NODE_FARM;         // 10%
        if (roll < 55) return AB_NODE_BLACKSMITH;   // 45%
        if (roll < 75) return AB_NODE_LUMBER_MILL;  // 20%
        return AB_NODE_GOLD_MINE;                   // 25%
    }
}

bool BGTactics::ShouldRushContestedObjectives()
{
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return false;
    
    // During opening (first 2 min), rush contested objectives
    if (IsGameOpening(bg))
    {
        uint32 assignedNode = GetAssignedOpeningNode(bg);
        TeamId myTeam = bot->GetTeamId();
        
        // Skip home base defense unless specifically assigned
        if (myTeam == TEAM_ALLIANCE && assignedNode != AB_NODE_STABLES)
            return true; // Don't defend Stables unless assigned
        else if (myTeam == TEAM_HORDE && assignedNode != AB_NODE_FARM)
            return true; // Don't defend Farm unless assigned
    }
    
    return false;
}

bool BGTactics::MoveToABNode(uint32 nodeIndex)
{
    Position targetPos;
    
    switch (nodeIndex)
    {
        case AB_NODE_STABLES:
            targetPos = AB_NODE_POS_STABLES;
            break;
        case AB_NODE_BLACKSMITH:
            targetPos = AB_NODE_POS_BLACKSMITH;
            break;
        case AB_NODE_FARM:
            targetPos = AB_NODE_POS_FARM;
            break;
        case AB_NODE_LUMBER_MILL:
            targetPos = AB_NODE_POS_LUMBER_MILL;
            break;
        case AB_NODE_GOLD_MINE:
            targetPos = AB_NODE_POS_GOLD_MINE;
            break;
        default:
            return false;
    }
    
    return MoveTo(bot->GetMapId(), targetPos.GetPositionX(), targetPos.GetPositionY(), targetPos.GetPositionZ());
}

// Objective Focus System Implementation

// Local helper to check flag carrier status (same logic as in TargetValue.cpp)
static bool IsFlagCarrierBG(Unit* unit)
{
    if (!unit || !unit->IsPlayer())
        return false;
    
    Player* player = unit->ToPlayer();
    
    // WSG flag carrier auras
    if (player->HasAura(23333) || player->HasAura(23335))
        return true;
    
    // EotS flag carrier aura
    if (player->HasAura(34976))
        return true;
    
    return false;
}

bool BGTactics::ShouldEngageInCombat(Unit* target)
{
    if (!target) return false;
    
    // =============================================
    // FLAG CARRIER LOGIC - CRITICAL
    // =============================================
    // Guide: "flag_carrier_rules.avoid_fighting": true
    // Flag carriers should FLEE, not fight
    if (bot->HasAura(BG_WS_SPELL_WARSONG_FLAG) ||
        bot->HasAura(BG_WS_SPELL_SILVERWING_FLAG) ||
        bot->HasAura(BG_EY_NETHERSTORM_FLAG_SPELL))
    {
        // Only engage if:
        // 1. Already in combat with this specific target
        // 2. Target is attacking us directly
        if (bot->GetVictim() == target || target->GetVictim() == bot)
        {
            // Already engaged - fight back
            LOG_DEBUG("playerbots", "BGTactics: {} carrying flag but already engaged with {}",
                      bot->GetName().c_str(), target->GetName().c_str());
            return true;
        }
        
        // Otherwise FLEE - don't engage
        LOG_DEBUG("playerbots", "BGTactics: {} carrying flag - avoiding combat with {}",
                  bot->GetName().c_str(), target->GetName().c_str());
        return false;
    }
    
    // 1. ALWAYS fight if we are defending a node we own/contest
    if (IsDefendingObjective())
        return true;
        
    // 2. NEVER fight if we are carrying a flag (objective is to run)
    // Exception: If target is literally in our face (8 yards) and attacking us
    if (HasCriticalObjective())
    {
        if (target->GetDistance(bot) < 8.0f && (target->GetVictim() == bot || bot->GetVictim() == target))
            return true;
            
        return false; // Run!
    }
        
    // 3. FIGHT if we are capturing a node and enemy tries to stop us
    // (If we are near a node we want, and enemy is there, we must kill them to cap)
    if (IsNearObjective(30.0f))
        return true;
        
    // 4. Default: Fight if attacked or target is close
    if (bot->GetVictim() == target || target->GetVictim() == bot)
        return true;
    
    Battleground* bg = bot->GetBattleground();
    if (!bg) return true; // Not in BG

    // 4.5 SITUATIONAL AVOIDANCE: AV Opening Rush
    // During the first 3 minutes of AV, bypass mid-field fights entirely unless attacked
    if (bg->GetBgTypeID() == BATTLEGROUND_AV && bg->GetStartTime() < 180000)
    {
        // Only engage if they are targetting us and within 15 yards
        if (target->GetVictim() == bot && target->GetDistance(bot) < 15.0f)
            return true;
            
        return false; // Keep Rushing!
    }

    // 5. Existing logic overrides:
    if (!target->IsPlayer()) return true; // PvE always ok
    
    Player* enemy = target->ToPlayer();
    
    // ALWAYS ENGAGE: Flag carriers
    if (IsFlagCarrierBG(enemy)) return true;
    
    // ALWAYS ENGAGE: Target attacking our flag carrier
    Unit* fcVictim = enemy->GetVictim();
    if (fcVictim && fcVictim->IsPlayer())
    {
        Player* victimPlayer = fcVictim->ToPlayer();
        if (victimPlayer->GetTeamId() == bot->GetTeamId() && IsFlagCarrierBG(victimPlayer))
            return true; 
    }
    
    // =============================================
    // UNIVERSAL OBJECTIVE-FOCUSED COMBAT AVOIDANCE
    // =============================================
    // Dynamic system: If bot is rushing to a high-priority objective,
    // avoid unnecessary mid-field combat to reach it faster
    
    // Check if we have a high-priority objective we're rushing to
    WorldObject* currentObjective = GetCurrentObjective();
    bool hasHighPriorityObjective = false;
    float distanceToObjective = 9999.0f;
    
    if (currentObjective && currentObjective->IsInWorld() && currentObjective->GetMapId() == bot->GetMapId())
    {
        distanceToObjective = bot->GetDistance(currentObjective);
        
        // Determine if this is a HIGH priority objective worth rushing for
        // (vs. low priority like "roaming" or "general defense")
        
        BattlegroundTypeId bgType = bg->GetBgTypeID();
        if (bgType == BATTLEGROUND_RB)
            bgType = bg->GetBgTypeID(true);
        
        switch (bgType)
        {
            case BATTLEGROUND_AV:
            {
                // High priority: Captains, Bosses, Towers
                if (Creature* creature = currentObjective->ToCreature())
                {
                    uint32 entry = creature->GetEntry();
                    if (entry == AV_CREATURE_A_CAPTAIN ||
                        entry == AV_CREATURE_H_CAPTAIN ||
                        entry == AV_CREATURE_A_BOSS ||
                        entry == AV_CREATURE_H_BOSS)
                    {
                        hasHighPriorityObjective = true;
                    }
                }
                // Towers/Graveyards
                else if (currentObjective->ToGameObject())
                {
                    hasHighPriorityObjective = true;
                }
                break;
            }
            
            case BATTLEGROUND_AB:
            case BATTLEGROUND_EY:
            {
                // High priority: Any node/flag we're trying to capture
                if (currentObjective->ToGameObject())
                {
                    hasHighPriorityObjective = true;
                }
                break;
            }
            
            case BATTLEGROUND_IC:
            {
                // High priority: Workshops, Hangar, Docks, Boss
                if (currentObjective->ToGameObject() || currentObjective->ToCreature())
                {
                    hasHighPriorityObjective = true;
                }
                break;
            }
            
            case BATTLEGROUND_WS:
            {
                // High priority: Enemy flag (already handled by flag carrier logic above)
                if (currentObjective->ToGameObject())
                {
                    hasHighPriorityObjective = true;
                }
                break;
            }
            
            default:
                break;
        }
    }
    
    // =============================================
    // APPLY OBJECTIVE-FOCUSED COMBAT RULES
    // =============================================
    if (hasHighPriorityObjective)
    {
        // We're rushing to a high-value objective
        
        // Exception 1: Already in combat with this target - fight back
        if (bot->GetVictim() == target || target->GetVictim() == bot)
        {
            LOG_DEBUG("playerbots", "BGTactics: {} already engaged with {} - fighting back",
                      bot->GetName().c_str(), enemy->GetName().c_str());
            return true;
        }
        
        // Exception 2: Very close to objective - engage to clear defenders
        // The closer we are, the more we need to clear enemies
        float engageRadius;
        if (distanceToObjective < 30.0f)
            engageRadius = 30.0f;  // Close - clear all nearby threats
        else if (distanceToObjective < 60.0f)
            engageRadius = 15.0f;  // Medium - only engage very close threats
        else
            engageRadius = 8.0f;   // Far - only if they're right on top of us
        
        float distanceToEnemy = bot->GetDistance(target);
        if (distanceToEnemy <= engageRadius)
        {
            LOG_DEBUG("playerbots", "BGTactics: {} engaging {} (close to objective, dist: {:.1f})",
                      bot->GetName().c_str(), enemy->GetName().c_str(), distanceToEnemy);
            return true;
        }
        
        // Default: IGNORE and keep rushing to objective
        LOG_DEBUG("playerbots", "BGTactics: {} ignoring {} (rushing to objective {:.0f}y away)",
                  bot->GetName().c_str(), enemy->GetName().c_str(), distanceToObjective);
        return false;
    }
    
    // No high-priority objective - use default combat rules
    return true;  
}

bool BGTactics::IsNearObjective(float maxDistance)
{
    // SAFETY FIX: BgObjective can be a dangling pointer when BG objects despawn/change ownership
    // Removed unsafe pointer usage - use only position-based logic instead
    Battleground* bg = bot->GetBattleground();
    if (!bg) 
        return false;
    
    Position objectivePos = GetNearestObjectivePosition();
    if (objectivePos.GetPositionX() == 0.0f && objectivePos.GetPositionY() == 0.0f)
        return false; 
    
    return bot->GetDistance(objectivePos) <= maxDistance;
}

bool BGTactics::IsTargetThreateningObjective(Unit* target)
{
    if (!target)
        return false;
    
    Position objectivePos = GetNearestObjectivePosition();
    if (objectivePos.GetPositionX() == 0.0f && objectivePos.GetPositionY() == 0.0f)
        return false;
    
    // Target is near objective (within 40 yards)
    return target->GetDistance(objectivePos) <= 40.0f;
}

bool BGTactics::IsDefendingObjective()
{
    // If our objective is a node we own, we are defending
    // But how do we know if we own it? BgObjective is just a GO.
    // For now, check if we are near an objective and stationary.
    
    if (!IsNearObjective(30.0f))
        return false;
    
    // If we're moving slowly or stationary near objective, we're defending
    return !bot->isMoving() || bot->GetSpeed(MOVE_RUN) < 7.0f;
}

bool BGTactics::IsAttackingObjective()
{
    // Check if bot is moving toward an objective to capture
    // Simplified: if moving and within range of objective
    return bot->isMoving() && IsNearObjective(50.0f);
}

Position BGTactics::GetNearestObjectivePosition()
{
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return Position();
    
    BattlegroundTypeId bgType = bg->GetBgTypeID();
    if (bgType == BATTLEGROUND_RB)
        bgType = bg->GetBgTypeID(true);
    
    float nearestDist = 999999.0f;
    Position nearestPos;
    
    switch (bgType)
    {
        case BATTLEGROUND_WS:
        {
            // WSG: Flag rooms
            Position flags[] = {WS_FLAG_POS_ALLIANCE, WS_FLAG_POS_HORDE};
            for (auto& pos : flags)
            {
                float dist = bot->GetDistance(pos);
                if (dist < nearestDist)
                {
                    nearestDist = dist;
                    nearestPos = pos;
                }
            }
            break;
        }
        case BATTLEGROUND_AB:
        {
            // AB: All 5 bases
            Position bases[] = {
                AB_NODE_POS_STABLES,
                AB_NODE_POS_BLACKSMITH,
                AB_NODE_POS_FARM,
                AB_NODE_POS_LUMBER_MILL,
                AB_NODE_POS_GOLD_MINE
            };
            for (auto& pos : bases)
            {
                float dist = bot->GetDistance(pos);
                if (dist < nearestDist)
                {
                    nearestDist = dist;
                    nearestPos = pos;
                }
            }
            break;
        }
        case BATTLEGROUND_EY:
        {
            // EotS: Mid flag + 4 bases
            Position objectives[] = {
                {2174.782f, 1569.054f, 1160.361f, 0.0f}, // Mid flag
                {2047.19f, 1735.07f, 1187.91f, 0.0f},    // Fel Reaver
                {2047.19f, 1349.19f, 1189.0f, 0.0f},     // Blood Elf
                {2276.8f, 1400.41f, 1196.33f, 0.0f},     // Draenei Ruins
                {2282.102f, 1760.006f, 1189.707f, 0.0f}  // Mage Tower
            };
            for (auto& pos : objectives)
            {
                float dist = bot->GetDistance(pos);
                if (dist < nearestDist)
                {
                    nearestDist = dist;
                    nearestPos = pos;
                }
            }
            break;
        }
        default:
            break;
    }
    
    return nearestPos;
}

bool ArenaTactics::Execute(Event event)
{
    if (!bot->InBattleground())
    {
        bool IsRandomBot = sRandomPlayerbotMgr->IsRandomBot(bot->GetGUID().GetCounter());
        botAI->ChangeStrategy("-arena", BOT_STATE_COMBAT);
        botAI->ChangeStrategy("-arena", BOT_STATE_NON_COMBAT);
        botAI->ResetStrategies(!IsRandomBot);
        return false;
    }

    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return false;

    if (bg->GetStatus() == STATUS_WAIT_LEAVE)
        return BGStatusAction::LeaveBG(botAI);

    if (bg->GetStatus() != STATUS_IN_PROGRESS)
        return false;

    if (bot->isDead())
        return false;

    if (bot->isMoving())
        return false;

    // startup phase
    if (bg->GetStartDelayTime() > 0)
        return false;

    if (botAI->HasStrategy("collision", BOT_STATE_NON_COMBAT))
        botAI->ChangeStrategy("-collision", BOT_STATE_NON_COMBAT);

    if (botAI->HasStrategy("buff", BOT_STATE_NON_COMBAT))
        botAI->ChangeStrategy("-buff", BOT_STATE_NON_COMBAT);

    Unit* target = bot->GetVictim();
    if (target)
    {
        bool losBlocked = !bot->IsWithinLOSInMap(target) || fabs(bot->GetPositionZ() - target->GetPositionZ()) > 5.0f;

        if (losBlocked)
        {
            PathGenerator path(bot);
            path.CalculatePath(target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(), false);

            if (path.GetPathType() != PATHFIND_NOPATH)
            {
                // If you are casting a spell and lost your target due to LoS, interrupt the cast and move
                if (bot->IsNonMeleeSpellCast(false, true, true, false, true))
                    bot->InterruptNonMeleeSpells(true);

                float x, y, z;
                target->GetPosition(x, y, z);
                botAI->TellMasterNoFacing("Repositioning to exit the LoS target!");
                return MoveTo(target->GetMapId(), x + frand(-1, +1), y + frand(-1, +1), z, false, true);
            }
        }
    }

    // Priority 1: Check if teammates are in combat nearby (3D distance for platforms)
    GuidVector members = AI_VALUE(GuidVector, "group members");
    for (auto& memberGuid : members)
    {
        Player* ally = botAI->GetPlayer(memberGuid);
        if (!ally || !ally->IsAlive() || ally->GetGUID() == bot->GetGUID())
            continue;

        // Check if ally is in combat
        if (!ally->IsInCombat())
            continue;

        // Check 3D distance (important for platforms like Ring of Valor)
        float distance = bot->GetExactDist(ally);
        if (distance > 40.0f)  // Within 40 yards
            continue;

        // Ally is nearby and in combat - move to help!
        if (distance > 5.0f)  // Don't move if already very close
        {
            return MoveTo(ally->GetMapId(), ally->GetPositionX(), ally->GetPositionY(), ally->GetPositionZ(),
                         false, false, false, false, MovementPriority::MOVEMENT_COMBAT);
        }
        return false;  // Close enough, let combat AI take over
    }

    // Priority 2: If not in combat, move to center to group up
    if (!bot->IsInCombat())
        return moveToCenter(bg);

    return true;
}

bool ArenaTactics::moveToCenter(Battleground* bg)
{
    // Sanity check
    if (!bg)
    {
        return true;
    }
    uint32 Preference = 6;

    switch (bot->getClass())
    {
        case CLASS_PRIEST:
        case CLASS_SHAMAN:
        case CLASS_DRUID:
            Preference = 3;
            break;
        case CLASS_WARRIOR:
        case CLASS_PALADIN:
        case CLASS_ROGUE:
        case CLASS_DEATH_KNIGHT:
            Preference = 6;
            break;
        case CLASS_HUNTER:
        case CLASS_MAGE:
        case CLASS_WARLOCK:
            Preference = 9;
            break;
    }

    switch (bg->GetBgTypeID())
    {
        case BATTLEGROUND_BE:
            if (bg->GetTeamStartPosition(bot->GetBgTeamId())->GetPositionY() < 240)
            {
                if (Preference == 3)
                    MoveTo(bg->GetMapId(), 6226.65f + frand(-1, +1), 264.36f + frand(-1, +1), 1.31f, false, true);
                else if (Preference == 6)
                    MoveTo(bg->GetMapId(), 6239.89f + frand(-1, +1), 261.11f + frand(-1, +1), 0.89f, false, true);
                else
                    MoveTo(bg->GetMapId(), 6235.60f + frand(-1, +1), 258.27f + frand(-1, +1), 0.89f, false, true);
            }
            else
            {
                if (Preference == 3)
                    MoveTo(bg->GetMapId(), 6265.72f + frand(-1, +1), 271.92f + frand(-1, +1), 3.65f, false, true);
                else if (Preference == 6)
                    MoveTo(bg->GetMapId(), 6239.89f + frand(-1, +1), 261.11f + frand(-1, +1), 0.89f, false, true);
                else
                    MoveTo(bg->GetMapId(), 6250.50f + frand(-1, +1), 266.66f + frand(-1, +1), 2.63f, false, true);
            }
            break;
        case BATTLEGROUND_RL:
            if (bg->GetTeamStartPosition(bot->GetBgTeamId())->GetPositionY() < 1600)
            {
                if (Preference == 3)
                    MoveTo(bg->GetMapId(), 1262.14f + frand(-1, +1), 1657.63f + frand(-1, +1), 33.76f, false, true);
                else if (Preference == 6)
                    MoveTo(bg->GetMapId(), 1266.85f + frand(-1, +1), 1663.52f + frand(-1, +1), 34.04f, false, true);
                else
                    MoveTo(bg->GetMapId(), 1274.07f + frand(-1, +1), 1656.36f + frand(-1, +1), 34.58f, false, true);
            }
            else
            {
                if (Preference == 3)
                    MoveTo(bg->GetMapId(), 1261.93f + frand(-1, +1), 1669.27f + frand(-1, +1), 34.25f, false, true);
                else if (Preference == 6)
                    MoveTo(bg->GetMapId(), 1266.85f + frand(-1, +1), 1663.52f + frand(-1, +1), 34.04f, false, true);
                else
                    MoveTo(bg->GetMapId(), 1266.37f + frand(-1, +1), 1672.40f + frand(-1, +1), 34.21f, false, true);
            }
            break;
        case BATTLEGROUND_NA:
            if (bg->GetTeamStartPosition(bot->GetBgTeamId())->GetPositionY() < 2870)
            {
                if (Preference == 3)
                    MoveTo(bg->GetMapId(), 4068.85f + frand(-1, +1), 2911.98f + frand(-1, +1), 12.99f, false, true);
                else if (Preference == 6)
                    MoveTo(bg->GetMapId(), 4056.99f + frand(-1, +1), 2919.75f + frand(-1, +1), 13.51f, false, true);
                else
                    MoveTo(bg->GetMapId(), 4056.27f + frand(-1, +1), 2905.33f + frand(-1, +1), 12.90f, false, true);
            }
            else
            {
                if (Preference == 3)
                    MoveTo(bg->GetMapId(), 4043.66f + frand(-1, +1), 2927.93f + frand(-1, +1), 13.17f, false, true);
                else if (Preference == 6)
                    MoveTo(bg->GetMapId(), 4056.99f + frand(-1, +1), 2919.75f + frand(-1, +1), 13.51f, false, true);
                else
                    MoveTo(bg->GetMapId(), 4054.80f + frand(-1, +1), 2934.28f + frand(-1, +1), 13.72f, false, true);
            }
            break;
        case BATTLEGROUND_DS:
            if (!MoveTo(bg->GetMapId(), 1291.58f + frand(-5, +5), 790.87f + frand(-5, +5), 7.8f, false, true))
            {
                // they like to hang around at the tip of the pipes doing nothing, so we just teleport them down
                if (bot->GetDistance(1333.07f, 817.18f, 13.35f) < 4)
                {
                    bot->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TELEPORTED | AURA_INTERRUPT_FLAG_CHANGE_MAP);
                    bot->TeleportTo(bg->GetMapId(), 1330.96f, 816.75f, 3.2f, bot->GetOrientation());
                }
                if (bot->GetDistance(1250.13f, 764.79f, 13.34f) < 4)
                {
                    bot->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_TELEPORTED | AURA_INTERRUPT_FLAG_CHANGE_MAP);
                    bot->TeleportTo(bg->GetMapId(), 1252.19f, 765.41f, 3.2f, bot->GetOrientation());
                }
            }
            break;
        case BATTLEGROUND_RV:
            MoveTo(bg->GetMapId(), 764.65f + frand(-2, +2), -283.85f + frand(-2, +2), 28.28f, false, true);
            break;
        default:
            break;
    }

    return true;
}

// ==========================================
// ARENA INTELLIGENCE METHODS
// ==========================================

// Get Arena Focus Target - Coordinate all DPS on enemy healer
Unit* BGTactics::GetArenaFocusTarget()
{
    if (!bot->InArena())
        return nullptr;

    // Priority 1: Enemy healer (alive)
    GuidVector targets = AI_VALUE(GuidVector, "possible targets");
    Unit* enemyHealer = nullptr;
    Unit* lowHPTarget = nullptr;
    float lowestHP = 100.0f;

    for (auto guid : targets)
    {
        Unit* unit = botAI->GetUnit(guid);
        if (!unit || !unit->IsPlayer() || !unit->IsAlive())
            continue;

        Player* enemy = unit->ToPlayer();
        
        // Check if healer
        if (botAI->IsHeal(enemy))
        {
            if (!enemyHealer || enemy->GetHealthPct() < enemyHealer->GetHealthPct())
                enemyHealer = enemy;
        }

        // Track lowest HP target as fallback
        float hp = enemy->GetHealthPct();
        if (hp < lowestHP)
        {
            lowestHP = hp;
            lowHPTarget = enemy;
        }
    }

    // Return healer if alive, otherwise lowest HP target
    return enemyHealer ? enemyHealer : lowHPTarget;
}

// Check if should focus healer in arena
bool BGTactics::ShouldFocusHealer()
{
    if (!bot->InArena())
        return false;

    Unit* focusTarget = GetArenaFocusTarget();
    if (!focusTarget || !focusTarget->IsPlayer())
        return false;

    // Focus healer if one exists
    return botAI->IsHeal(focusTarget->ToPlayer());
}

// Check if bot is under heavy pressure (taking damage from multiple enemies)
bool BGTactics::IsUnderHeavyPressure()
{
    if (!bot->InArena() && !bot->InBattleground())
        return false;

    // Check attacker count
    uint8 attackerCount = AI_VALUE(uint8, "attacker count");
    
    // Under heavy pressure if:
    // 1. Multiple attackers (2+)
    // 2. Low HP (<40%)
    // 3. Combination of attackers + low HP
    
    if (attackerCount >= 2)
        return true;

    if (bot->GetHealthPct() < 40.0f && attackerCount > 0)
        return true;

    return false;
}

// Check if should use defensive cooldown
bool BGTactics::ShouldUseDefensiveCooldown()
{
    if (!bot->InArena() && !bot->InBattleground())
        return false;

    // Use defensive if under heavy pressure
    if (IsUnderHeavyPressure())
        return true;

    // Use defensive if HP dropping rapidly (lost >30% HP recently)
    if (bot->GetHealthPct() < 50.0f && bot->IsInCombat())
    {
        uint8 attackerCount = AI_VALUE(uint8, "attacker count");
        if (attackerCount >= 2)
            return true;
    }

    // Emergency defensive at very low HP
    if (bot->GetHealthPct() < 25.0f && bot->IsInCombat())
        return true;

    return false;
}

// Check if it's a good burst window (enemy vulnerable)
bool BGTactics::IsBurstWindow()
{
    if (!bot->InArena())
        return false;

    Unit* focusTarget = GetArenaFocusTarget();
    if (!focusTarget || !focusTarget->IsPlayer())
        return false;

    float targetHP = focusTarget->GetHealthPct();
    
    // Burst window: Target HP < 60% AND (healer CC'd OR target CC'd OR very low HP)
    if (targetHP < 60.0f && (IsEnemyHealerCCd() || CountEnemyHealers() == 0))
        return true;
    
    if (targetHP < 40.0f)
        return true;

    // Target is CC'd
    if (focusTarget->HasUnitState(UNIT_STATE_STUNNED) || focusTarget->HasUnitState(UNIT_STATE_CONTROLLED))
        return true;

    return false;
}

// Check if should use burst cooldown
bool BGTactics::ShouldUseBurstCooldown()
{
    if (!bot->InArena())
        return false;

    if (IsBurstWindow())
        return true;

    // Use burst if we outnumber enemies and target is low
    Unit* focusTarget = GetArenaFocusTarget();
    if (focusTarget && focusTarget->GetHealthPct() < 50.0f)
    {
        GuidVector targets = AI_VALUE(GuidVector, "possible targets");
        uint8 aliveEnemies = 0;
        for (auto guid : targets)
        {
            Unit* unit = botAI->GetUnit(guid);
            if (unit && unit->IsPlayer() && unit->IsAlive())
                aliveEnemies++;
        }

        Group* group = bot->GetGroup();
        if (group)
        {
            uint8 aliveAllies = 0;
            for (GroupReference* ref = group->GetFirstMember(); ref; ref = ref->next())
            {
                Player* member = ref->GetSource();
                if (member && member->IsAlive())
                    aliveAllies++;
            }
            if (aliveAllies > aliveEnemies)
                return true;
        }
    }
    return false;
}

// Count enemy healers in arena
uint8 BGTactics::CountEnemyHealers()
{
    if (!bot->InArena())
        return 0;

    GuidVector targets = AI_VALUE(GuidVector, "possible targets");
    uint8 healerCount = 0;
    for (auto guid : targets)
    {
        Unit* unit = botAI->GetUnit(guid);
        if (unit && unit->IsPlayer() && unit->IsAlive() && botAI->IsHeal(unit->ToPlayer()))
            healerCount++;
    }
    return healerCount;
}

// Check if enemy healer is CC'd
bool BGTactics::IsEnemyHealerCCd()
{
    if (!bot->InArena())
        return false;

    GuidVector targets = AI_VALUE(GuidVector, "possible targets");
    for (auto guid : targets)
    {
        Unit* unit = botAI->GetUnit(guid);
        if (!unit || !unit->IsPlayer() || !unit->IsAlive())
            continue;

        Player* enemy = unit->ToPlayer();
        if (botAI->IsHeal(enemy))
        {
            if (enemy->HasUnitState(UNIT_STATE_STUNNED) ||
                enemy->HasUnitState(UNIT_STATE_CONTROLLED) ||
                enemy->HasUnitState(UNIT_STATE_CONFUSED) ||
                enemy->HasAuraType(SPELL_AURA_MOD_FEAR))
                return true;
        }
    }
    return false;
}

// ==========================================
// TEAM COORDINATION METHODS
// ==========================================

bool BGTactics::ShouldProtectHealer()
{
    if (!bot->InBattleground() && !bot->InArena())
        return false;
    if (botAI->IsHeal(bot))
        return false;
    return IsAllyHealerThreatened();
}

Unit* BGTactics::GetAllyHealer()
{
    Group* group = bot->GetGroup();
    if (!group)
        return nullptr;
    for (GroupReference* ref = group->GetFirstMember(); ref; ref = ref->next())
    {
        Player* member = ref->GetSource();
        if (member && member != bot && member->IsAlive() && botAI->IsHeal(member))
            return member;
    }
    return nullptr;
}

bool BGTactics::IsAllyHealerThreatened()
{
    Unit* healer = GetAllyHealer();
    if (!healer)
        return false;
    GuidVector attackers = AI_VALUE(GuidVector, "attackers");
    for (auto guid : attackers)
    {
        Unit* attacker = botAI->GetUnit(guid);
        if (attacker && (attacker->GetVictim() == healer || attacker->GetDistance(healer) < 10.0f))
            return true;
    }
    return false;
}

bool BGTactics::ShouldEscortFlagCarrier()
{
    if (!bot->InBattleground())
        return false;
    if (bot->HasAura(23333) || bot->HasAura(23335) || bot->HasAura(34976))
        return false;
    Group* group = bot->GetGroup();
    if (!group)
        return false;
    for (GroupReference* ref = group->GetFirstMember(); ref; ref = ref->next())
    {
        Player* member = ref->GetSource();
        if (member && member != bot && member->IsAlive())
        {
            if (member->HasAura(23333) || member->HasAura(23335) || member->HasAura(34976))
            {
                if (bot->GetDistance(member) < 40.0f)
                    return true;
            }
        }
    }
    return false;
}

// ==========================================
// TACTICAL VISION & RISK ASSESSMENT  
// ==========================================

// Count enemies near a position (tactical vision - range + height only, no LoS)
uint8 BGTactics::CountEnemiesNearPosition(Position pos, float radius)
{
    if (!bot->InBattleground())
        return 0;

    GuidVector targets = AI_VALUE(GuidVector, "possible targets");
    uint8 count = 0;

    for (auto guid : targets)
    {
        Unit* unit = botAI->GetUnit(guid);
        if (!unit || !unit->IsPlayer() || !unit->IsAlive())
            continue;

        float dist = unit->GetDistance(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ());
        
        // Range check
        if (dist > radius)
            continue;

        // Height check (reasonable Z-axis limit)
        float zDiff = fabs(bot->GetPositionZ() - unit->GetPositionZ());
        if (zDiff > 15.0f)
            continue;

        count++;
    }

    return count;
}

// Count allies near a position (range + height, no LoS)
uint8 BGTactics::CountAlliesNearPosition(Position pos, float radius)
{
    if (!bot->InBattleground())
        return 0;

    Group* group = bot->GetGroup();
    if (!group)
        return 1; // Just the bot

    uint8 count = 0;

    for (GroupReference* ref = group->GetFirstMember(); ref; ref = ref->next())
    {
        Player* member = ref->GetSource();
        if (!member || !member->IsAlive())
            continue;

        float dist = member->GetDistance(pos.GetPositionX(), pos.GetPositionY(), pos.GetPositionZ());
        
        // Range check
        if (dist > radius)
            continue;

        // Height check
        float zDiff = fabs(bot->GetPositionZ() - member->GetPositionZ());
        if (zDiff > 15.0f)
            continue;

        count++;
    }

    return count;
}

// Check if it's safe to attack an objective (not outnumbered)
bool BGTactics::IsSafeToAttackObjective(Position objPos)
{
    if (!bot->InBattleground())
        return true;

    uint8 enemies = CountEnemiesNearPosition(objPos, 40.0f);
    uint8 allies = CountAlliesNearPosition(objPos, 40.0f);

    // CRITICAL SITUATION OVERRIDE: Attack anyway if urgent!
    // Examples: Enemy FC about to cap, heavily losing, last seconds
    if (IsCriticalSituation())
        return true;  // JUST GO FOR IT!

    // Safe if: 
    // 1. No enemies
    // 2. Equal or more allies than enemies
    // 3. Only 1 enemy and we have at least 1 ally nearby
    
    if (enemies == 0)
        return true;

    if (allies >= enemies)
        return true;

    // Risky: outnumbered scenario (e.g., 1v3)
    // Only attack if the disadvantage is small (1v2 okay, 1v3+ not okay)
    if (enemies - allies >= 2)
        return false;

    return true;
}

// Get the safest objective to attack (best ally:enemy ratio)
Position BGTactics::GetSafestObjective()
{
    if (!bot->InBattleground())
        return bot->GetPosition();

    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return bot->GetPosition();

    // AB: Full node tactical analysis
    if (bg->GetBgTypeID() == BATTLEGROUND_AB)
    {
        Position bestObj = bot->GetPosition();
        float bestRatio = -999.0f;

        Position nodes[5] = {
            {1166.0f, 1200.0f, -56.0f, 0.0f},  // Stables
            {1063.0f, 1313.0f, -56.0f, 0.0f},  // Blacksmith
            {990.0f, 1008.0f, -42.0f, 0.0f},   // Gold Mine
            {817.0f, 843.0f, 11.0f, 0.0f},     // Lumber Mill
            {729.0f, 1167.0f, -16.0f, 0.0f}    // Farm
        };

        for (int i = 0; i < 5; i++)
        {
            uint8 enemies = CountEnemiesNearPosition(nodes[i], 40.0f);
            uint8 allies = CountAlliesNearPosition(nodes[i], 40.0f);

            float ratio = allies - enemies;
            if (enemies == 0)
                ratio = 10.0f;

            if (ratio > bestRatio)
            {
                bestRatio = ratio;
                bestObj = nodes[i];
            }
        }

        return bestObj;
    }

    // OTHER BGs: Use nearest objective (already has good logic)
    // WSG, EotS, AV, IoC, SotA all use GetNearestObjectivePosition
    // which is implemented elsewhere and works universally
    return GetNearestObjectivePosition();
}


// Check if should regroup before attacking (outnumbered)
bool BGTactics::ShouldRegroupBeforeAttack()
{
    if (!bot->InBattleground())
        return false;

    Position nearestObj = GetNearestObjectivePosition();
    
    // Check if we're outnumbered at nearest objective
    uint8 enemies = CountEnemiesNearPosition(nearestObj, 40.0f);
    uint8 allies = CountAlliesNearPosition(nearestObj, 40.0f);

    // Regroup if outnumbered by 2+ enemies
    if (enemies >= allies + 2)
        return true;

    return false;
}

// ==========================================
// URGENCY OVERRIDES (Critical Situations)
// ==========================================

// Check if situation demands aggressive play despite risk
bool BGTactics::IsCriticalSituation()
{
    if (!bot->InBattleground())
        return false;

    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return false;

    // CRITICAL 1: Enemy FC about to score (WSG, EotS)
    if (IsEnemyFCNearCap())
        return true;  // MUST ATTACK even if 1v5!

    // CRITICAL 2: Heavily losing (need aggressive plays)
    if (IsLosingBadly(bg))
        return true;

    // CRITICAL 3: Allied FC in danger (must help!)
    Group* group = bot->GetGroup();
    if (group)
    {
        for (GroupReference* ref = group->GetFirstMember(); ref; ref = ref->next())
        {
            Player* member = ref->GetSource();
            if (member && member->IsAlive())
            {
                // Allied FC exists and is low HP
                if ((member->HasAura(23333) || member->HasAura(23335) || member->HasAura(34976)) &&
                    member->GetHealthPct() < 50.0f)
                    return true;  // MUST HELP FC!
            }
        }
    }

    return false;
}

// Check if enemy FC is near their cap point
bool BGTactics::IsEnemyFCNearCap()
{
    if (!bot->InBattleground())
        return false;

    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return false;

    // Only for flag BGs
    if (bg->GetBgTypeID() != BATTLEGROUND_WS && bg->GetBgTypeID() != BATTLEGROUND_EY)
        return false;

    // Find enemy FC
    GuidVector targets = AI_VALUE(GuidVector, "possible targets");
    for (auto guid : targets)
    {
        Unit* unit = botAI->GetUnit(guid);
        if (!unit || !unit->IsPlayer())
            continue;

        Player* enemy = unit->ToPlayer();

        // Check if enemy has flag
        if (enemy->HasAura(23333) || enemy->HasAura(23335) || enemy->HasAura(34976))
        {
            float x = enemy->GetPositionX();
            float y = enemy->GetPositionY();

            if (bg->GetBgTypeID() == BATTLEGROUND_WS)
            {
                // Horde FC near Alliance base (about to cap)
                if (enemy->GetTeamId() == TEAM_HORDE)
                {
                    if (x > 1500 && x < 1580 && y > 1440 && y < 1520)
                        return true;  // EMERGENCY!
                }
                // Alliance FC near Horde base
                else
                {
                    if (x > 880 && x < 960 && y > 1390 && y < 1480)
                        return true;  // EMERGENCY!
                }
            }
            else if (bg->GetBgTypeID() == BATTLEGROUND_EY)
            {
                // Near flag cap point in middle
                if (x > 2000 && x < 2100 && y > 1320 && y < 1420)
                    return true;  // EMERGENCY!
            }
        }
    }

    return false;
}

// ==========================================
// IOC VEHICLE & COORDINATION METHODS
// ==========================================

// Check if bot is driving a siege engine
bool BGTactics::IsDrivingSiegeEngine()
{
    if (!bot->GetVehicle())
        return false;
    
    Unit* vehicle = bot->GetVehicle()->GetBase();
    if (!vehicle)
        return false;
    
    // Siege Engine NPCs: Alliance 34776, Horde 35273
    uint32 entry = vehicle->GetEntry();
    return (entry == 34776 || entry == 35273);
}

// Check if bot is a passenger in any vehicle
bool BGTactics::IsVehiclePassenger()
{
    // Simple check: in vehicle but not the first person to enter (driver)
    // For IoC purposes, we just need to know if bot is passenger
    if (!bot->GetVehicle())
        return false;
    
    // If in vehicle, assume passenger for now (specific seat check causes issues)
    // Driver actions vs passenger actions will be handled in action logic
    return true;
}

// Get enemy gate position for IoC
Position BGTactics::GetEnemyGatePosition()
{
    // Alliance Gate: ~341, -872, 47 (Horde attacks)
    // Horde Gate: ~1270, -765, 48 (Alliance attacks)
    if (bot->GetTeamId() == TEAM_ALLIANCE)
        return Position(1270.0f, -765.0f, 48.0f, 0.0f);  // Horde gate
    else
        return Position(341.0f, -872.0f, 47.0f, 0.0f);   // Alliance gate
}

// Find nearest siege vehicle to enter
Unit* BGTactics::FindNearestSiegeVehicle(float radius)
{
    if (!bot->InBattleground())
        return nullptr;
    
    // Use existing bot AI to get all units
    GuidVector targets = AI_VALUE(GuidVector, "all targets");
    Unit* nearestVehicle = nullptr;
    float nearestDist = radius;
    
    for (auto guid : targets)
    {
        Unit* unit = botAI->GetUnit(guid);
        if (!unit || !unit->IsVehicle())
            continue;
        
        // Check siege engine entries
        uint32 entry = unit->GetEntry();
        if (entry != 34776 && entry != 35273)  // Not a siege engine
            continue;
        
        // Check faction
        if (unit->GetFaction() != bot->GetFaction())
            continue;
        
        // Check distance
        if (unit->IsInWorld() && unit->GetMapId() == bot->GetMapId())
        {
            float dist = bot->GetDistance(unit);
            if (dist < nearestDist)
            {
                nearestDist = dist;
                nearestVehicle = unit;
            }
        }
    }
    
    return nearestVehicle;
}

// Check if should wait for allies before siege assault
bool BGTactics::ShouldWaitForSiegeGroup()
{
    if (!IsDrivingSiegeEngine())
        return false;
    
    // Count nearby allies for escort
    uint8 nearbyAllies = CountAlliesNearPosition(bot->GetPosition(), 30.0f);
    
    // Wait if less than 3 allies nearby
    return nearbyAllies < 3;
}

// Check if should protect allied siege engine
bool BGTactics::ShouldProtectSiegeEngine()
{
    Unit* siegeEngine = FindAlliedSiegeEngine(40.0f);
    if (!siegeEngine)
        return false;
    
    // Check if siege has attackers
    uint8 enemies = CountEnemiesNearPosition(siegeEngine->GetPosition(), 20.0f);
    return enemies > 0;
}

// Find allied siege engine to protect
Unit* BGTactics::FindAlliedSiegeEngine(float radius)
{
    if (!bot->InBattleground())
        return nullptr;
    
    // Use existing bot AI
    GuidVector targets = AI_VALUE(GuidVector, "all targets");
    
    for (auto guid : targets)
    {
        Unit* unit = botAI->GetUnit(guid);
        if (!unit || !unit->IsVehicle())
            continue;
        
        // Check siege engine entries
        uint32 entry = unit->GetEntry();
        if (entry != 34776 && entry != 35273)
            continue;
        
        // Check faction
        if (unit->GetFaction() != bot->GetFaction())
            continue;
        
        // Check distance
        if (unit->IsInWorld() && unit->GetMapId() == bot->GetMapId() && bot->GetDistance(unit) <= radius)
            return unit;
    }
    
    return nullptr;
}

// Check if team controls Workshop
bool BGTactics::TeamControlsWorkshop()
{
    if (!bot->InBattleground())
        return false;
    
    Battleground* bg = bot->GetBattleground();
    if (!bg || bg->GetBgTypeID() != BATTLEGROUND_IC)
        return false;
    
    // Workshop node check (implementation depends on BG API)
    // Placeholder: assume controlled if bots near workshop
    return true;  // TODO: Implement actual workshop control check
}

// Check if team controls Hangar
bool BGTactics::TeamControlsHangar()
{
    if (!bot->InBattleground())
        return false;
    
    Battleground* bg = bot->GetBattleground();
    if (!bg || bg->GetBgTypeID() != BATTLEGROUND_IC)
        return false;
    
    // Hangar control check
    return true;  // TODO: Implement actual hangar control check
}

// =============================================
// EOTS ADAPTIVE CAPTURE LOGIC
// =============================================

// Find the best base to capture/defend in EotS
uint32 BGTactics::GetSafestObjectiveEY()
{
    Battleground* bg = bot->GetBattleground();
    if (!bg || bg->GetBgTypeID() != BATTLEGROUND_EY)
        return 0;

    TeamId myTeam = bot->GetTeamId();
    float bestScore = -1.0f;
    uint32 bestBase = 0;

    for (uint32 i = 0; i < 4; ++i)
    {
        Position basePos = GetNodePosition(i, BATTLEGROUND_EY);
        
        // Skip if base is currently being heavily contested by too many enemies
        uint8 enemies = CountEnemiesNearPosition(basePos, 40.0f);
        uint8 allies = CountAlliesNearPosition(basePos, 40.0f);
        
        // Score based on:
        // 1. Proximity
        // 2. Ally:Enemy ratio
        // 3. Current ownership (prioritize defending owned bases if carrying flag)
        
        float dist = bot->GetDistance(basePos);
        float ratio = (allies + 1.0f) / (enemies + 1.0f);
        bool owned = bg->ToBattlegroundEY()->GetCapturePointInfo(i)._ownerTeamId == myTeam;
        
        float score = (1000.0f / (dist + 1.0f)) * ratio;
        if (owned && HasCriticalObjective())
            score *= 2.0f; // Strongly prioritize home bases if carrying flag
            
        if (score > bestScore)
        {
            bestScore = score;
            bestBase = i;
        }
    }
    
    return bestBase;
}

// =============================================
// REACTIVE DEFENSE SYSTEM IMPLEMENTATION
// =============================================

// Global node state storage
// Global node state storage
std::unordered_map<uint32, std::unordered_map<uint32, NodeStateInfo>> bgNodeStates;
std::recursive_mutex bgNodeStatesMutex;

// Update node states and detect changes - called periodically
void BGTactics::UpdateNodeStates(Battleground* bg)
{
    // Safety checks
    if (!bg || !bot)
        return;

    BattlegroundTypeId bgType = bg->GetBgTypeID();
    if (bgType == BATTLEGROUND_RB)
        bgType = bg->GetBgTypeID(true);
    
    // Only process node-based battlegrounds
    if (bgType != BATTLEGROUND_AB && bgType != BATTLEGROUND_EY && bgType != BATTLEGROUND_IC)
        return;

    uint32 bgInstanceId = bg->GetInstanceID();
    TeamId botTeam = bot->GetTeamId();

    // LOCK MUTEX
    std::lock_guard<std::recursive_mutex> lock(bgNodeStatesMutex);

    // Throttling Logic (Thread-Safe)
    static std::unordered_map<uint32, time_t> lastUpdateTime;
    time_t now = time(nullptr);
    
    if (lastUpdateTime.find(bgInstanceId) != lastUpdateTime.end() && 
        (now - lastUpdateTime[bgInstanceId]) < 2)
    {
        return; // Throttled
    }
    lastUpdateTime[bgInstanceId] = now;

    // Arathi Basin node state tracking
    if (bgType == BATTLEGROUND_AB)
    {
        BattlegroundAB* abBg = dynamic_cast<BattlegroundAB*>(bg);
        if (!abBg)
            return;

        // Track all 5 AB nodes
        for (uint32 nodeId = 0; nodeId < 5; ++nodeId)
        {
            NodeStateInfo& nodeInfo = bgNodeStates[bgInstanceId][nodeId];
            nodeInfo.nodeId = nodeId;
            nodeInfo.position = GetNodePosition(nodeId, bgType);
            nodeInfo.previousState = nodeInfo.currentState;

            // Get node state from BG
            CaptureABPointInfo const& captureInfo = abBg->GetCapturePointInfo(nodeId);
            uint8 nodeState = captureInfo._state;
            TeamId nodeOwner = captureInfo._ownerTeamId;
            
            // Decode node state
            NodeOwnerState newState = NODE_STATE_NEUTRAL;
            
            // Check current state using BG_AB_NODE_STATE enums
            if (nodeState == BG_AB_NODE_STATE_NEUTRAL)
            {
                newState = NODE_STATE_NEUTRAL;
            }
            else if (nodeState == BG_AB_NODE_STATE_ALLY_OCCUPIED && nodeOwner == botTeam)
            {
                newState = NODE_STATE_ALLY_CONTROLLED;
            }
            else if (nodeState == BG_AB_NODE_STATE_HORDE_OCCUPIED && nodeOwner == botTeam)
            {
                newState = NODE_STATE_ALLY_CONTROLLED;
            }
            else if ((nodeState == BG_AB_NODE_STATE_ALLY_OCCUPIED || nodeState == BG_AB_NODE_STATE_HORDE_OCCUPIED) && nodeOwner != botTeam)
            {
                newState = NODE_STATE_ENEMY_CONTROLLED;
            }
            else if (nodeState == BG_AB_NODE_STATE_ALLY_CONTESTED && botTeam == TEAM_ALLIANCE)
            {
                // Alliance is contesting - we're capturing enemy node
                newState = NODE_STATE_ENEMY_CONTESTED;
            }
            else if (nodeState == BG_AB_NODE_STATE_HORDE_CONTESTED && botTeam == TEAM_HORDE)
            {
                // Horde is contesting - we're capturing enemy node
                newState = NODE_STATE_ENEMY_CONTESTED;
            }
            else if (nodeState == BG_AB_NODE_STATE_ALLY_CONTESTED && botTeam == TEAM_HORDE)
            {
                // Alliance is contesting our node - defend!
                newState = NODE_STATE_ALLY_CONTESTED;
            }
            else if (nodeState == BG_AB_NODE_STATE_HORDE_CONTESTED && botTeam == TEAM_ALLIANCE)
            {
                // Horde is contesting our node - defend!
                newState = NODE_STATE_ALLY_CONTESTED;
            }

            // Detect state change
            if (newState != nodeInfo.currentState)
            {
                nodeInfo.currentState = newState;
                nodeInfo.stateChangeTime = time(nullptr);

                // Trigger event handlers
                if (nodeInfo.previousState == NODE_STATE_ALLY_CONTROLLED &&
                    newState == NODE_STATE_ALLY_CONTESTED)
                {
                    OnNodeContested(nodeId, nodeInfo.position);
                }
                else if (nodeInfo.previousState == NODE_STATE_ALLY_CONTROLLED &&
                         newState == NODE_STATE_ENEMY_CONTROLLED)
                {
                    OnNodeLost(nodeId, nodeInfo.position);
                }
                else if (newState == NODE_STATE_ALLY_CONTROLLED &&
                         nodeInfo.previousState == NODE_STATE_ALLY_CONTESTED)
                {
                    OnNodeRecaptured(nodeId);
                }
            }

            // Update defensive priority
            if (newState == NODE_STATE_ALLY_CONTESTED)
            {
                nodeInfo.needsDefense = true;
                float timeRemaining = GetCaptureTimeRemaining(nodeId);
                nodeInfo.defensivePriority = GetDefensiveRecapturePriority(nodeId, nodeInfo.position);
            }
            else
            {
                nodeInfo.needsDefense = false;
                nodeInfo.defensivePriority = 0.0f;
            }
        }
    }
    // Eye of the Storm tracking (4 bases)
    else if (bgType == BATTLEGROUND_EY)
    {
        // Similar logic for EotS bases
        for (uint32 nodeId = 0; nodeId < 4; ++nodeId)
        {
            NodeStateInfo& nodeInfo = bgNodeStates[bgInstanceId][nodeId];
            nodeInfo.nodeId = nodeId;
            nodeInfo.position = GetNodePosition(nodeId, bgType);
            // Simplified - actual implementation needs EotS-specific node state checks
        }
    }
}

// Handler: Our node is being captured
// Handler: Our node is being captured
void BGTactics::OnNodeContested(uint32 nodeId, Position pos)
{
    std::lock_guard<std::recursive_mutex> lock(bgNodeStatesMutex);
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return;

    BattlegroundTypeId bgType = bg->GetBgTypeID();
    if (bgType == BATTLEGROUND_RB)
        bgType = bg->GetBgTypeID(true);

    std::string nodeName = GetNodeName(nodeId, bgType);
    
    LOG_DEBUG("playerbots", "BGTactics: {} detected {} is being captured! Triggering defensive response.",
              bot->GetName(), nodeName);

    // Mark this node for defensive priority
    bgNodeStates[bg->GetInstanceID()][nodeId].needsDefense = true;
}

// Handler: We lost a node
// Handler: We lost a node
void BGTactics::OnNodeLost(uint32 nodeId, Position pos)
{
    std::lock_guard<std::recursive_mutex> lock(bgNodeStatesMutex);
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return;

    BattlegroundTypeId bgType = bg->GetBgTypeID();
    if (bgType == BATTLEGROUND_RB)
        bgType = bg->GetBgTypeID(true);

    std::string nodeName = GetNodeName(nodeId, bgType);
    
    LOG_DEBUG("playerbots", "BGTactics: {} - ALERT! {} has been lost to enemy!",
              bot->GetName(), nodeName);
}

// Handler: We recaptured a node
// Handler: We recaptured a node
void BGTactics::OnNodeRecaptured(uint32 nodeId)
{
    std::lock_guard<std::recursive_mutex> lock(bgNodeStatesMutex);
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return;

    bgNodeStates[bg->GetInstanceID()][nodeId].needsDefense = false;
    
    LOG_DEBUG("playerbots", "BGTactics: {} - Successfully defended/recaptured node {}!",
              bot->GetName(), nodeId);
}

// Check if this node needs defensive recapture
bool BGTactics::IsDefensiveRecaptureTarget(uint32 nodeId)
{
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return false;

    std::lock_guard<std::recursive_mutex> lock(bgNodeStatesMutex);
    auto& nodes = bgNodeStates[bg->GetInstanceID()];
    if (nodes.find(nodeId) == nodes.end())
        return false;

    return nodes[nodeId].needsDefense;
}

// Calculate defensive recapture priority
float BGTactics::GetDefensiveRecapturePriority(uint32 nodeId, Position nodePos)
{
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return 0.0f;

    BattlegroundTypeId bgType = bg->GetBgTypeID();
    if (bgType == BATTLEGROUND_RB)
        bgType = bg->GetBgTypeID(true);

    // Base strategic value
    float baseValue = GetNodeStrategicValue(nodeId, bgType);
    
    // Time urgency multiplier (more urgent as timer runs out)
    float timeRemaining = GetCaptureTimeRemaining(nodeId);
    float urgencyMultiplier = GetDefensivePriorityMultiplier(timeRemaining);
    
    // Proximity bonus (closer bots get higher priority)
    float distance = bot->GetDistance(nodePos.GetPositionX(), nodePos.GetPositionY(), nodePos.GetPositionZ());
    float proximityBonus = 1.0f;
    if (distance < 50.0f)
        proximityBonus = 2.0f;  // Very close - high priority
    else if (distance < 100.0f)
        proximityBonus = 1.5f;  // Medium distance
    else if (distance > DEFENSIVE_RESPONSE_RADIUS)
        proximityBonus = 0.1f;  // Too far - low priority

    // Calculate final priority
    float priority = baseValue * DEFENSIVE_PRIORITY_MULTIPLIER_BASE * urgencyMultiplier * proximityBonus;

    // Log decision
    LOG_DEBUG("playerbots", "BGTactics: {} defense priority for node {} = {:.2f} (base={:.1f}, urgency={:.2f}, proximity={:.2f})",
              bot->GetName(), nodeId, priority, baseValue, urgencyMultiplier, proximityBonus);

    return priority;
}

// Should this bot respond to defense?
bool BGTactics::ShouldRespondToDefense(uint32 nodeId, Position nodePos)
{
    // Don't respond if carrying flag
    if (HasCriticalObjective())
        return false;

    // Check distance
    float distance = bot->GetDistance(nodePos.GetPositionX(), nodePos.GetPositionY(), nodePos.GetPositionZ());
    if (distance > DEFENSIVE_RESPONSE_RADIUS)
        return false;

    // Check if enough allies already responding
    uint8 alliesAtNode = GetAlliesAtNode(nodeId, nodePos);
    uint8 enemiesAtNode = GetEnemiesAtNode(nodeId, nodePos);
    
    // Need at least enough to match enemies + 1
    uint32 neededDefenders = std::min(static_cast<uint32>(enemiesAtNode + 1), MAX_DEFENDERS_RESPONSE);
    
    if (alliesAtNode >= neededDefenders)
    {
        LOG_DEBUG("playerbots", "BGTactics: {} - enough defenders ({}) at node {}, not responding",
                  bot->GetName(), alliesAtNode, nodeId);
        return false;
    }

    return true;
}

// Find closest contested node that needs defense
uint32 BGTactics::GetClosestContestedNode()
{
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return UINT32_MAX;

    std::lock_guard<std::recursive_mutex> lock(bgNodeStatesMutex);
    auto& nodes = bgNodeStates[bg->GetInstanceID()];
    
    float closestDist = 99999.0f;
    uint32 closestNode = UINT32_MAX;

    for (auto& pair : nodes)
    {
        if (!pair.second.needsDefense)
            continue;

        float dist = bot->GetDistance(pair.second.position.GetPositionX(), 
                                       pair.second.position.GetPositionY(), 
                                       pair.second.position.GetPositionZ());
        if (dist < closestDist)
        {
            closestDist = dist;
            closestNode = pair.first;
        }
    }

    return closestNode;
}

// Get capture time remaining (simplified - actual needs BG API)
float BGTactics::GetCaptureTimeRemaining(uint32 nodeId)
{
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return AB_CAPTURE_TIME;

    auto& nodes = bgNodeStates[bg->GetInstanceID()];
    if (nodes.find(nodeId) == nodes.end())
        return AB_CAPTURE_TIME;

    time_t elapsed = time(nullptr) - nodes[nodeId].stateChangeTime;
    float remaining = AB_CAPTURE_TIME - static_cast<float>(elapsed);
    return std::max(0.0f, remaining);
}

// Get base strategic value for a node
float BGTactics::GetNodeStrategicValue(uint32 nodeId, BattlegroundTypeId bgType)
{
    if (bgType == BATTLEGROUND_AB)
    {
        // AB strategic values (Blacksmith most important)
        switch (nodeId)
        {
            case AB_NODE_BLACKSMITH:  return 1.5f;  // Central, highest value
            case AB_NODE_LUMBER_MILL: return 1.2f;  // Good position
            case AB_NODE_STABLES:     return 1.0f;  // Alliance side
            case AB_NODE_FARM:        return 1.0f;  // Horde side
            case AB_NODE_GOLD_MINE:   return 0.8f;  // Far corner
            default: return 1.0f;
        }
    }
    else if (bgType == BATTLEGROUND_EY)
    {
        // EotS values - bases near flag spawn more valuable
        switch (nodeId)
        {
            case 0:  // Mage Tower
            case 1:  // Draenei Ruins
                return 1.2f;  // Near center
            case 2:  // Blood Elf Tower
            case 3:  // Fel Reaver Ruins
                return 1.0f;
            default: return 1.0f;
        }
    }
    
    return 1.0f;
}

// Calculate urgency multiplier based on time remaining
float BGTactics::GetDefensivePriorityMultiplier(float timeRemaining)
{
    // Scale from 1.0 (just started) to 2.0 (about to lose)
    // Formula: 1.0 + (1 - timeRemaining/60) +' ranges from 1.0 to 2.0
    float urgency = 1.0f + (1.0f - (timeRemaining / AB_CAPTURE_TIME));
    return std::min(2.0f, std::max(1.0f, urgency));
}

// Check if bot has critical objective (flag carrier, etc.)
bool BGTactics::HasCriticalObjective()
{
    // Check if carrying BG flags
    if (bot->HasAura(BG_WS_SPELL_WARSONG_FLAG) || 
        bot->HasAura(BG_WS_SPELL_SILVERWING_FLAG) ||
        bot->HasAura(BG_EY_NETHERSTORM_FLAG_SPELL))
    {
        return true;
    }
    
    return false;
}

// Get node position for a given BG type
Position BGTactics::GetNodePosition(uint32 nodeId, BattlegroundTypeId bgType)
{
    if (bgType == BATTLEGROUND_AB)
    {
        switch (nodeId)
        {
            case AB_NODE_STABLES:     return AB_NODE_POS_STABLES;
            case AB_NODE_BLACKSMITH:  return AB_NODE_POS_BLACKSMITH;
            case AB_NODE_FARM:        return AB_NODE_POS_FARM;
            case AB_NODE_LUMBER_MILL: return AB_NODE_POS_LUMBER_MILL;
            case AB_NODE_GOLD_MINE:   return AB_NODE_POS_GOLD_MINE;
            default: return Position();
        }
    }
    else if (bgType == BATTLEGROUND_EY)
    {
        // EotS base positions (approximate)
        switch (nodeId)
        {
            case 0: return Position(2048.8f, 1393.65f, 1194.05f);  // Mage Tower
            case 1: return Position(2286.56f, 1402.36f, 1197.11f); // Draenei Ruins
            case 2: return Position(2048.35f, 1749.68f, 1190.03f); // Blood Elf Tower
            case 3: return Position(2284.48f, 1731.13f, 1189.99f); // Fel Reaver Ruins
            default: return Position();
        }
    }
    
    return Position();
}

// Get readable node name
std::string BGTactics::GetNodeName(uint32 nodeId, BattlegroundTypeId bgType)
{
    if (bgType == BATTLEGROUND_AB)
    {
        switch (nodeId)
        {
            case AB_NODE_STABLES:     return "Stables";
            case AB_NODE_BLACKSMITH:  return "Blacksmith";
            case AB_NODE_FARM:        return "Farm";
            case AB_NODE_LUMBER_MILL: return "Lumber Mill";
            case AB_NODE_GOLD_MINE:   return "Gold Mine";
            default: return "Unknown";
        }
    }
    else if (bgType == BATTLEGROUND_EY)
    {
        switch (nodeId)
        {
            case 0: return "Mage Tower";
            case 1: return "Draenei Ruins";
            case 2: return "Blood Elf Tower";
            case 3: return "Fel Reaver Ruins";
            default: return "Unknown";
        }
    }
    
    return "Unknown";
}

// Count enemies at a node position
// Count enemies at a node position
uint8 BGTactics::GetEnemiesAtNode(uint32 nodeId, Position nodePos)
{
    return CountEnemiesNearPosition(nodePos, 40.0f);
}

// Count allies at a node position
uint8 BGTactics::GetAlliesAtNode(uint32 nodeId, Position nodePos)
{
    return CountAlliesNearPosition(nodePos, 40.0f);
}

// =============================================
// SECURE-BEFORE-CAPTURE LOGIC (NEW)
// =============================================

// Get list of enemies near a position (returns Unit* for targeting)
std::vector<Unit*> BGTactics::GetNearbyEnemies(Position pos, float radius)
{
    std::vector<Unit*> enemies;
    
    if (!bot)
        return enemies;
    
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return enemies;
    
    TeamId myTeam = bot->GetTeamId();
    
    // Get all players in battleground
    for (auto const& itr : bg->GetPlayers())
    {
        Player* player = itr.second;
        if (!player || player->GetTeamId() == myTeam)
            continue;
        
        if (!player->IsAlive())
            continue;
        
        // Check if within radius
        if (pos.GetExactDist2d(player->GetPosition()) <= radius)
            enemies.push_back(player);
    }
    
    return enemies;
}

// Get list of allies near a position (returns Unit* for coordination)
std::vector<Unit*> BGTactics::GetNearbyAllies(Position pos, float radius)
{
    std::vector<Unit*> allies;
    
    if (!bot)
        return allies;
    
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return allies;
    
    TeamId myTeam = bot->GetTeamId();
    
    // Get all players in battleground
    for (auto const& itr : bg->GetPlayers())
    {
        Player* player = itr.second;
        if (!player || player->GetTeamId() != myTeam)
            continue;
        
        if (!player->IsAlive())
            continue;
        
        // Don't count self
        if (player->GetGUID() == bot->GetGUID())
            continue;
        
        // Check if within radius
        if (pos.GetExactDist2d(player->GetPosition()) <= radius)
            allies.push_back(player);
    }
    
    return allies;
}

// Determine if bot should secure area before attempting capture
bool BGTactics::ShouldSecureBeforeCapture(Position objectivePos)
{
    // Check for nearby enemies within 40 yards of objective
    uint8 enemyCount = CountEnemiesNearPosition(objectivePos, 40.0f);
    uint8 allyCount = CountAlliesNearPosition(objectivePos, 40.0f);
    
    // If no enemies, area is secure
    if (enemyCount == 0)
        return false;
    
    // If enemies outnumber us 2:1 or more, definitely secure first
    if (enemyCount >= allyCount * 2)
        return true;
    
    // Get actual enemy units to check their state
    std::vector<Unit*> nearbyEnemies = GetNearbyEnemies(objectivePos, 40.0f);
    
    // If any enemy is actively in combat or has a victim, secure first
    for (Unit* enemy : nearbyEnemies)
    {
        if (enemy->IsInCombat() || enemy->GetVictim())
            return true;
    }
    
    // If we have significantly more allies, can attempt capture
    if (allyCount >= enemyCount + 2)  // +2 advantage
        return false;
    
    // Default: secure if any enemies present
    return true;
}


// =============================================
// STUCK DETECTION & RECOVERY
// =============================================

// Position history for stuck detection (static to persist between calls)
static std::unordered_map<ObjectGuid, std::vector<Position>> botPositionHistory;
static std::unordered_map<ObjectGuid, time_t> botLastMoveTime;

// Check if bot is stuck
bool BGTactics::IsStuck()
{
    if (!bot)
        return false;
    
    ObjectGuid guid = bot->GetGUID();
    time_t now = time(nullptr);
    Position currentPos = bot->GetPosition();
    
    // Initialize if first check
    if (botPositionHistory.find(guid) == botPositionHistory.end())
    {
        botPositionHistory[guid] = {currentPos};
        botLastMoveTime[guid] = now;
        return false;
    }
    
    // Get history
    std::vector<Position>& history = botPositionHistory[guid];
    
    // Keep only last 15 positions
    if (history.size() > 15)
        history.erase(history.begin());
    
    history.push_back(currentPos);
    
    // Need at least 15 samples
    if (history.size() < 15)
        return false;
    
    // Calculate total distance moved in last 15 checks
    float totalDistance = 0.0f;
    for (size_t i = 1; i < history.size(); ++i)
    {
        totalDistance += history[i-1].GetExactDist(&history[i]);
    }
    
    // Stuck if moved less than 5 yards in 15 seconds
    if (totalDistance < 5.0f && (now - botLastMoveTime[guid]) > 15)
    {
        LOG_DEBUG("playerbots", "BGTactics: {} detected as stuck (moved {:.2f} yards in 15s)", 
                  bot->GetName(), totalDistance);
        return true;
    }
    else if (totalDistance > 5.0f)
    {
        botLastMoveTime[guid] = now;
    }
    
    return false;
}

// Recover from stuck state
void BGTactics::RecoverFromStuck()
{
    if (!bot)
        return;
    
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return;
    
    LOG_DEBUG("playerbots", "BGTactics: {} attempting stuck recovery", bot->GetName());
    
    // Strategy 1: Stop movement and clear motion master
    bot->StopMoving();
    bot->GetMotionMaster()->Clear();
    bot->GetMotionMaster()->MoveIdle();
    
    // Strategy 2: Try to jump
    float jumpX = bot->GetPositionX() + frand(-2.0f, 2.0f);
    float jumpY = bot->GetPositionY() + frand(-2.0f, 2.0f);
    float jumpZ = bot->GetPositionZ() + 1.0f;
    
    bot->GetMotionMaster()->MoveJump(jumpX, jumpY, jumpZ, 10.0f, 10.0f);
    
    // Strategy 3: Reset objective on next tick
    // This will force bot to recalculate path
    PositionMap& posMap = context->GetValue<PositionMap&>("position")->Get();
    posMap[" bg objective"].Reset();
    
    // Clear position history for this bot
    ObjectGuid guid = bot->GetGUID();
    botPositionHistory[guid].clear();
    botLastMoveTime[guid] = time(nullptr);
    
    LOG_DEBUG("playerbots", "BGTactics: {} stuck recovery complete", bot->GetName());
}

// ==========================================
// CAPTURE COOLDOWN & THREAT MANAGEMENT
// ==========================================

/**
 * @brief Sets a cooldown timer before the bot can attempt to capture again
 * @param durationMs Duration of cooldown in milliseconds
 */
void BGTactics::SetCaptureCooldown(uint32 durationMs)
{
    if (!bot)
        return;
    
    // Store cooldown expiration time in static map
    time_t expirationTime = time(nullptr) + (durationMs / 1000);
    botCaptureCooldowns[bot->GetGUID()] = expirationTime;
    
    LOG_DEBUG("playerbots", "BGTactics: {} set capture cooldown for {}ms", bot->GetName(), durationMs);
}

/**
 * @brief Checks if the bot is currently on capture cooldown
 * @return true if bot should wait before attempting capture, false otherwise
 */
bool BGTactics::IsOnCaptureCooldown()
{
    if (!bot)
        return false;
    
    ObjectGuid guid = bot->GetGUID();
    if (botCaptureCooldowns.find(guid) == botCaptureCooldowns.end())
        return false;
        
    time_t cooldownExpiration = botCaptureCooldowns[guid];
    
    // If cooldown is 0, bot has never set a cooldown (allowed to capture)
    if (cooldownExpiration == 0)
        return false;
    
    time_t currentTime = time(nullptr);
    
    // Check if cooldown has expired
    if (currentTime >= cooldownExpiration)
    {
        // Cooldown expired, clear it
        botCaptureCooldowns[guid] = 0;
        return false;
    }
    
    // Still on cooldown
    return true;
}

/**
 * @brief Calculates the threat level at a position based on enemy vs ally count
 * @param pos Position to check
 * @param radius Search radius
 * @return Threat ratio: >1.0 means more enemies than allies (dangerous), <1.0 means advantage
 */
float BGTactics::GetAreaThreatLevel(Position pos, float radius)
{
    if (!bot)
        return 0.0f;
    
    Battleground* bg = bot->GetBattleground();
    if (!bg)
        return 0.0f;
    
    TeamId botTeam = bot->GetTeamId();
    TeamId enemyTeam = botTeam == TEAM_ALLIANCE ? TEAM_HORDE : TEAM_ALLIANCE;
    
    // Count enemies and allies near the position
    uint32 enemyCount = getPlayersInArea(enemyTeam, pos, radius, true);
    uint32 allyCount = getPlayersInArea(botTeam, pos, radius, true);
    
    // Add self to ally count
    if (bot->GetDistance(pos) <= radius)
        allyCount++;
    
    // If no allies, area is extremely dangerous
    if (allyCount == 0)
        return 999.0f;
    
    // Calculate threat ratio
    float threatRatio = static_cast<float>(enemyCount) / static_cast<float>(allyCount);
    
    LOG_DEBUG("playerbots", "BGTactics: {} threat level at position: {} enemies, {} allies, ratio: {}", 
              bot->GetName(), enemyCount, allyCount, threatRatio);
    
    return threatRatio;
}


void BGTactics::UseSpeedSpells()
{
    if (!HasCriticalObjective())
        return;

    if (!bot->HasUnitState(UNIT_STATE_MOVING))
        return;

    uint8 cls = bot->getClass();
    switch (cls)
    {
        case CLASS_DRUID:
            if (bot->GetShapeshiftForm() != FORM_TRAVEL && botAI->CanCastSpell("travel form", bot))
                botAI->CastSpell("travel form", bot);
            break;
        case CLASS_ROGUE:
            if (!botAI->HasAura("sprint", bot) && botAI->CanCastSpell("sprint", bot))
                botAI->CastSpell("sprint", bot);
            break;
        case CLASS_SHAMAN:
            if (!botAI->HasAura("ghost wolf", bot) && botAI->CanCastSpell("ghost wolf", bot))
                botAI->CastSpell("ghost wolf", bot);
            break;
        case CLASS_MAGE:
            if (botAI->CanCastSpell("blink", bot))
                botAI->CastSpell("blink", bot);
            break;
        case CLASS_HUNTER:
            if (!botAI->HasAura("aspect of the cheetah", bot) && !bot->IsInCombat() && botAI->CanCastSpell("aspect of the cheetah", bot))
                botAI->CastSpell("aspect of the cheetah", bot);
            break;
        case CLASS_PALADIN:
            if (bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) && botAI->CanCastSpell("hand of freedom", bot))
                botAI->CastSpell("hand of freedom", bot);
            break;
        case CLASS_PRIEST:
            if (!botAI->HasAura("power word: shield", bot) && botAI->CanCastSpell("power word: shield", bot))
                botAI->CastSpell("power word: shield", bot);
            break;
    }
}

// ==========================================
// ISLE OF CONQUEST SPECIFIC TACTICS
// ==========================================

bool BGTactics::HandleIsleOfConquestTactics()
{
    if (!bot)
        return false;

    // 1. Vehicle Logic
    if (bot->GetVehicle())
    {
        if (IsDrivingSiegeEngine())
            return DriveSiegeEngine();
        
        if (IsVehiclePassenger())
            return LogicPassenger(); 
            
        return false; 
    }

    // 2. Bomb Logic (Seaforium)
    if (bot->HasAura(62507) || bot->HasAura(66313)) // Seaforium Bombs
    {
        return LogicBomb();
    }

    // 3. Teamwork: Peel for Healer
    if (DoPeelForHealer())
        return true;

    // 4. Objective Selection
    return ProcessIoCMechanics();
}

bool BGTactics::ProcessIoCMechanics()
{
    Battleground* bg = bot->GetBattleground();
    if (!bg) return false;

    // Basic Logic Override:
    // If Workshop is available and we don't have it, go for it.
    // If Hangar is available and we don't have it, go for it.
    
    // For now, return false to let default capture logic work, 
    // but this hook allows future expansion.
    return false; 
}

// Stub implementations (would need full vehicle API)
bool BGTactics::DriveSiegeEngine()
{
    // Drive to enemy gate
    // If near gate, cast Ram (Spell 12345 generic placeholder)
    return true; 
}

bool BGTactics::LogicPassenger()
{
    // If in turret, cast spells on enemies
    return true; 
}

bool BGTactics::LogicBomb()
{
    // If have bomb, move to gate
    // Use bomb
    return true; 
}

bool BGTactics::LogicGlaive() { return true; }
bool BGTactics::LogicDemolisher() { return true; }

// ==========================================
// TEAMWORK MECHANICS
// ==========================================

Unit* BGTactics::GetHealerToPeel()
{
    // Find nearby friendly healer under attack
    if (!bot) return nullptr;
    
    std::vector<Unit*> allies = GetNearbyAllies(bot->GetPosition(), 30.0f);
    for (Unit* ally : allies)
    {
        if (ally->GetHealthPct() < 70 && 
           (ally->getClass() == CLASS_PRIEST || ally->getClass() == CLASS_DRUID || 
            ally->getClass() == CLASS_PALADIN || ally->getClass() == CLASS_SHAMAN))
        {
            if (ally->GetVictim() || ally->IsInCombat())
                return ally;
        }
    }
    return nullptr;
}

bool BGTactics::DoPeelForHealer()
{
    Unit* healer = GetHealerToPeel();
    if (!healer)
        return false;

    // Find who is attacking the healer
    Unit* attacker = healer->getAttackerForHelper();
    if (!attacker)
        return false;

    // Peel!
    bot->Attack(attacker, true);
    // Cast CC if available (simplified)
    return true;
}
